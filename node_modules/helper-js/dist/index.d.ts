/**
 * get global, such as window in browser.
 * 返回顶级全局变量. 例如浏览器的`window`
 * @returns
 */
export declare function glb(): typeof globalThis;
/**
 * detect if global variable `document` existing.
 * 判断全局变量`document`是否存在
 * @returns
 */
export declare function isDocumentExisted(): boolean;
export declare function isArray<T>(v: unknown): v is any[];
export declare function isBool(v: unknown): v is boolean;
export declare function isNumber(v: unknown): v is number;
export declare function isNumeric(v: unknown): v is string;
export declare function isString(v: unknown): v is string;
export declare function isObject(v: unknown): v is object;
export declare function isFunction(v: unknown): v is Function;
export declare function isPromise(v: unknown): v is Promise<any>;
/**
 * detect if argumrnt is null, undefined, empty array, empty string, false, NaN, empty object
 * 检查是否是null, undefined, 空数组, 空字符串, false, NaN, 空对象
 * @param v
 * @returns
 */
export declare function empty(v: null | undefined | boolean | number | object | unknown[]): boolean;
/**
 * rand int in range, including min and max
 * 返回指定范围随机整数, 包括范围起始值和终止值
 * @param min
 * @param max
 * @returns
 */
export declare function randInt(min: number, max: number): number;
/**
 * rand item in array
 * 返回数组随机一项
 * @param arr
 * @returns
 */
export declare function randChoice<T>(arr: string | T[]): string | T;
/**
 * Pad a string to a certain length with another string
 * 左边补充指定字符, 使其达到指定长度
 * @param str
 * @param n
 * @param padString
 * @returns
 */
export declare function strPad(str: number | string, n: number, padString?: string): string | number;
/**
 * If n less than `min`, return `min`, else n.
 * 如果n小于min, 返回min, 否则n.
 * @param n
 * @param min
 * @returns
 */
export declare function notLessThan<T>(n: T, min: T): T;
/**
 * If n greater than `max`, return `max`, else n.
 * 如果n大于max, 返回max, 否则n.
 * @param n
 * @param max
 * @returns
 */
export declare function notGreaterThan<T>(n: T, max: T): T;
/**
 * limit min and max of value.
 * 限制值的最小和最大值.
 * @param n
 * @param min
 * @param max
 * @returns
 */
export declare function between<T>(n: T, min: T, max: T): T;
/**
 * 'abc abc' to 'Abc abc'
 * @param str
 * @returns
 */
export declare function studlyCase(str: string): string;
/**
 * To lower case and use `-` as delimiter. example: '-ABC abc_def camelCase-- helloMyFriend' to 'a-b-c-abc-def-camel-case-hello-my-friend'
 * @param str
 * @returns
 */
export declare function kebabCase(str: string): string;
/**
 * To lower case and use `_` as delimiter.
 * @param str
 * @returns
 */
export declare function snakeCase(str: string): string;
/**
 * 'abc-abc-abc_abc' to 'AbcAbcAbcAbc'
 * @param str
 * @returns
 */
export declare function camelCase(str: string): string;
/**
 * 'AbcAbcAbcAbc' to ['Abc', 'Abc', 'Abc', 'Abc']
 * @param str
 * @returns
 */
export declare function camelToWords(str: string): string[];
/**
 * 'abcAbc' to 'Abc Abc'
 * @param str
 * @returns
 */
export declare function titleCase(str: string): string;
/**
 * generate random string
 * 随机字符串
 * @param len default 8
 * @param seeds
 * @returns
 */
export declare function randString(len?: number, seeds?: string | string[]): string;
/**
 * reverse a string
 * @param str
 * @returns
 */
export declare function reverseString(str: string): string;
/**
 * remove item from array. return removed count
 * 从数组删除项. 返回删除计数
 * @param arr
 * @param v
 * @returns
 */
export declare function arrayRemove(arr: any[], v: any): number;
/**
 * remove items from array by sorted indexes. indexes example: [0, 2, 6, 8, 9]
 * 通过有序的索引集删除数组项. 索引集例子: [0, 2, 6, 8, 9]
 * @param arr
 * @param sortedIndexes
 */
export declare function arrayRemoveBySortedIndexes(arr: any[], sortedIndexes: number[]): void;
/**
 * get item from array by index. index can be negative number
 * 通过索引获取数组一项. 支持负值索引.
 * @param arr
 * @param n
 * @returns
 */
export declare function arrayAt<T>(arr: T[], n: number): T;
/**
 * get first or array
 * 返回数组首项
 * @param arr
 * @returns
 */
export declare function arrayFirst<T>(arr: T[]): T;
/**
 * get last of array
 * 返回数组末项
 * @param arr
 * @returns
 */
export declare function arrayLast<T>(arr: T[]): T;
/**
 *
 * @param arr1
 * @param arr2
 * @returns [diff1, diff2] diff1: in arr1 not in arr2. diff2: in arr2 not in arr1
 */
export declare function arrayDiff<T>(arr1: T[], arr2: T[]): [T[], T[]];
/**
 * like indexOf, get all indexes
 * @param strOrArr
 * @param item
 * @returns
 */
export declare function indexesOf(strOrArr: string | any[], item: any): number[];
/**
 * get array item siblings. Example: getArrayItemSiblings(arr, item, [-1, 1]), get previous and next sibling
 * 获得数组项的多个同级. 例: getArrayItemSiblings(arr, item, [-1, 1]), 获得前一个和后一个
 * @param arr
 * @param item
 * @param offsets
 * @returns
 */
export declare function getArrayItemSiblingsByOffsets<T>(arr: T[], item: any, offsets: number[]): T[];
export declare function toArrayIfNot<T>(arrOrNot: T | T[]): T[];
/**
 * Split array every n. n can be getter, which argument is the times.
 * 每n个拆分数组. n可以是方法, 参数是第几次分块
 * @param arr
 * @param n
 * @returns
 */
export declare function splitArray<T>(arr: T[], n: number | ((times: number) => number)): T[][];
/**
 * group array by mark
 * 计算每项的标识, 通过标识将数组项分组.
 * @param arr
 * @param getMark
 * @returns
 */
export declare function groupArray<T, R>(arr: T[], getMark: (item: T) => R): Map<R, T[]>;
/**
 * Each item in the new array is unique.
 * 新数组每项唯一.
 * @param arr
 * @param getMark
 * @returns
 */
export declare function arrayDistinct<T>(arr: T[], getMark?: (item: T, index: number) => unknown): T[];
/**
 * get items from array between 2 indeies. index can be negative
 * 从数组获得一个范围内的项. 范围可以为负.
 * @param arr
 * @param index
 * @param endIndex
 * @returns
 */
export declare function arrayBetween<T>(arr: T[], index: number, endIndex: number): T[];
/**
 * return new array excluding n items from end
 * 返回新数组排除末尾n项
 * @param arr
 * @param n
 * @returns
 */
export declare function arrayWithoutEnd<T>(arr: T[], n?: number): T[];
/**
 * get one-dimensional array from multidimensional array
 * 从多维数组获取一维数组
 * @param arr
 * @param depth
 * @returns
 */
export declare function arrayFlat<T>(arr: any[], depth?: number): T[];
/**
 * simplified array.filter()
 * e.g.: arrayFilter(arr, [null, undefined]) equal to arr.filter(v => v!== null && v!== undefined)
 * @param arr
 * @param without
 * @returns
 */
export declare function arrayFilter<T extends ArrayLike<any>>(arr: T, without: any[]): T;
/**
 * alias of arrayFilter
 */
export declare const arrayWithout: typeof arrayFilter;
/**
 * return JSON.parse(JSON.stringify(obj))
 * @param obj
 * @returns
 */
export declare function cloneObject<T>(obj: T): T;
/**
 * like Array.map
 * @param obj
 * @param handler
 * @returns
 */
export declare function objectMap(obj: object, handler: (value: any, key: string, index: number) => any): object;
export declare function objectOnly(obj: object, keys: string[]): object;
export declare function objectExcept(obj: object, keys: string[]): object;
export declare type IterateAllOptions = {
    reverse?: boolean;
    exclude?: (info: {
        value: any;
        index: number;
    } | {
        value: any;
        key: string;
    }) => boolean;
};
export declare function iterateAll<T>(val: string | any[] | object | NodeList | HTMLCollection, opt?: IterateAllOptions): Generator<{
    value: T;
    index?: number;
    key?: string;
}>;
export declare type FindAllCallback = (value: any, index: number) => void | boolean;
/**
 * like Array.find
 * @param list
 * @param callback
 * @param options
 * @returns
 */
export declare function findAll(list: Parameters<typeof iterateAll>[0], callback: FindAllCallback, options?: Parameters<typeof iterateAll>[1]): HTMLElement;
/**
 * example: dotGet(window, 'document.body.children.0')
 * @param obj
 * @param path
 * @param throwError
 * @returns
 */
export declare function dotGet(obj: object, path: string | string[], throwError?: boolean): any;
/**
 * example: dotSet(window, 'document.body.children.0', vaue)
 */
export declare function dotSet(obj: object, path: string | string[], value: any): void;
/**
 * try to delete obj[prop]
 * @param obj
 * @param prop
 * @returns
 */
export declare function unset(obj: object, prop: string): boolean;
export declare function assignIfNoKey(obj: object, key: string, val: any): void;
export declare function assignIfKeyNull(obj: object, key: string, val: any): void;
/**
 * Assign if value different. For assign sensitive, such as Vue.watch.
 * @param obj
 * @param key
 * @param val
 */
export declare function assignIfDiff(obj: object, key: string, val: any): void;
export declare function objectAssignIfNoKey<T extends object>(obj1: T, obj2: object): T;
export declare function objectAssignIfKeyNull<T extends object>(obj1: T, obj2: object): T;
export declare function objectAssignIfDiff<T extends object>(obj1: T, obj2: object): T;
export declare function withoutUndefined<T extends object>(obj: T): T;
/**
 * proxy a property to another key of this or another object
 * @param targetObj
 * @param targetKey
 * @param sourceObj
 * @param sourceKey
 */
export declare function objectDefineProxyProperty(targetObj: object, targetKey: string, sourceObj: object, sourceKey: string): void;
export declare type MapObjectTreeHandler = (value: any, key: string | number, parent: object | any[], newParent: object | any[]) => void | null | undefined | {
    key?: string;
    delete?: boolean;
    value?: any;
    skip?: boolean;
    stop?: boolean;
};
/**
 * walk object and change key, value, delete key. return cloned new object.
 * 深度遍历对象, 可以改变key, value, 删除key. 返回克隆的新对象.
 * @param obj
 * @param handler
 * return null: don't change anything
 * return {delete: true}: delete
 * return {key: newKey}: change key
 * return {value: newValue}: change value
 * return {skip: true}: skip children
 * return {stop: true}: stop
 * @param limit to prevent circular reference.
 * @returns
 */
export declare function mapObjectTree(obj: object, handler: MapObjectTreeHandler, limit?: number): object;
/**
 * [{id: 1}, {id: 2}] to {'1':{id: 1}, '2': {id: 2}}
 * @param arr
 * @param idKey
 * @returns
 */
export declare function mapObjects<T>(arr: T[], idKey: string | ((item: T, index: number) => string)): {
    [key: string]: T;
};
/**
 * example: pairRows(users, userProfiles, 'id', 'user_id')
 * @param rows1
 * @param rows2
 * @param key1
 * @param key2
 * @returns [{row1|null, row2|null},...]
 */
export declare function joinRows<T, Y>(rows1: T[], rows2: Y[], key1: string | ((row: T, index: number) => any), key2?: string, ignoreUnmatched?: boolean): [T | null, Y | null][];
export declare type TreeDataPath = number[];
export declare type WalkTreeDataHandler<T> = (node: T, index: number, parent: T | null, path: TreeDataPath) => void | false | "skip children" | "skip siblings";
export declare type WalkTreeDataOptions = {
    childrenKey?: string;
    reverse?: boolean;
    childFirst?: boolean;
};
/**
 * walk tree data by with depth first search. tree data example: `[{children: [{}, {}]}]`
 * 深度优先遍历树形数据. 树形数据示例: `[{children: [{}, {}]}]`
 * @param obj
 * @param handler
 * @param opt
 */
export declare function walkTreeData<T>(obj: T | T[], handler: WalkTreeDataHandler<T>, opt?: WalkTreeDataOptions): void;
export declare type TreeDataNodeInfo<T> = {
    node: T;
    index: number;
    parent: T | null;
    path: TreeDataPath;
};
/**
 * like Array.find
 * @param obj
 * @param handler return true when found.
 * @param opt
 * @returns
 */
export declare function findInfoInTreeData<T>(obj: T | T[], handler: FindTreeDataHandler<T>, opt?: FindTreeDataOptions): TreeDataNodeInfo<T> | undefined;
/**
 * like Array.find
 * @param obj
 * @param handler return true when found.
 * @param opt
 * @returns
 */
export declare function findTreeData<T>(obj: T | T[], handler: FindTreeDataHandler<T>, opt?: FindTreeDataOptions): T | undefined;
export declare type FindTreeDataHandler<T> = ReplaceReturnType<WalkTreeDataHandler<T>, any>;
export declare type FindTreeDataOptions = WalkTreeDataOptions;
export declare function cloneTreeData<T>(root: T, options?: {
    childrenKey?: string;
    nodeHandler?: CloneTreeNodeHandler<any>;
}): T;
export declare type CloneTreeNodeHandler<T> = (node: T, info: {
    oldNode: T;
    index: number;
    parent: T | null;
    path: TreeDataPath;
}) => T;
export declare class TreeData<Node> {
    data: Node | Node[];
    childrenKey: string;
    constructor(data?: Node | Node[]);
    get rootChildren(): Node[];
    iteratePath(path: TreeDataPath, opt?: {
        reverse?: boolean;
    }): IterableIterator<{
        path: TreeDataPath;
        node: Node;
    }>;
    getFamily(path: TreeDataPath): Node[];
    get(path: TreeDataPath): Node;
    getParentAndIndex(path: TreeDataPath): {
        parent: Node;
        index: number;
        parentPath: number[];
    };
    getParent(path: TreeDataPath): Node;
    set(path: TreeDataPath, node: Node): void;
    delete(path: TreeDataPath): Node | undefined;
    walk(handler: WalkTreeDataHandler<Node>, opt?: {
        reverse?: boolean;
    }): void;
    clone(opt?: {
        nodeHandler?: CloneTreeNodeHandler<Node>;
    }): {
        childrenKey: string;
        nodeHandler: CloneTreeNodeHandler<Node>;
    };
}
/**
 * if it is function, return result, else return it directly.
 * @param valueOrGetter
 * @param args
 * @returns
 */
export declare function resolveValueOrGettter(valueOrGetter: any, args?: any[]): any;
/**
 * add executed count as first argument of func
 * 增加执行次数作为方法的第一个参数
 * @param func
 * @returns
 */
export declare function executeWithCount<T>(func: T): OmitFirstParameter<T>;
/**
 * (getVal, handler) => update . when execute update, call getVal and check if changed.
 * (getVal, handler) => update . 执行update时, 调用getVal并检查结果是否改变.
 * @param getVal
 * @param handler
 * @returns
 */
export declare function watchChange<T>(getVal: ReplaceReturnType<OmitFirstParameter<T>, any>, handler: T): OmitFirstParameter<T>;
export declare function debounceTrailing<T>(action: T, wait?: number): {
    action: T;
    stop: () => void;
};
export declare function debounceImmediate<T>(action: T, wait?: number): {
    action: T;
    stop: () => void;
};
/**
 * the returned function only accept one argument
 * @param funcs
 * @returns
 */
export declare function joinFunctionsByResult(funcs: any[]): any;
/**
 * apply finally function to a function, execute it after target return, event it error
 * 在目标方法结束或出错后执行另一方法
 * @param func
 * @param finallyFunc
 * @returns
 */
export declare function applyFinally<T extends Function, Y extends Function>(func: T, finallyFunc: Y): T;
/**
 * must pass arguments to `next` manually
 * @param funcs
 * @returns
 */
export declare function joinFunctionsByNext(funcs: any[]): () => void;
/**
 * wrap function, bind context(this).
 * @param action
 * @param context
 * @returns
 */
export declare function bindContext<T extends Function>(action: T, context: any): T;
/**
 * Cache function return by arguments
 * @param func
 * @returns
 */
export declare function cacheFunction<T extends Function>(func: T, options?: {
    capacity?: number;
}): {
    action: T;
    clearCache: () => void;
};
/**
 * execute promise in sequence
 * @param getters
 * @param concurrent
 * @returns
 */
export declare function executePromiseGetters(getters: (() => any)[], concurrent?: number): {
    promise: Promise<unknown>;
    stop(): void;
};
export declare function promiseTimeout<T>(promise: Promise<T>, timeout: number): Promise<unknown>;
export declare function promisePin<T, E>(): {
    promise: Promise<T>;
    resolve: (arg: T) => void;
    reject: (error: E) => void;
};
/**
 * warp continuous Promise method, such as mousemove handler
 * @param method
 * @param opt. strategy 'last': the wrapped method return empty if skipped
 */
export declare function continuous<T extends (info: {
    count: number;
    currentCount: {
        value: number;
    };
}, ...args: any[]) => any>(method: T, opt?: {
    strategy: "every" | "last";
    resetCount?: boolean;
}): (...args: ParametersWithoutFirst<T>) => Promise<void | ReturnType<T>>;
export declare const promiseContinuous: typeof continuous;
export declare function getUrlParam(par: string): string | false;
export declare function pathJoin(p1: string, p2: string): string;
/**
 * return NodeList if there are multiple top-level nodes
 * @param htmlString
 * @returns
 */
export declare function createElementFromHTML(htmlString: string): ChildNode | NodeListOf<ChildNode>;
/**
 * NOT RECOMMEND. Use Node.contains instead.
 */
export declare function isDescendantOf(el: Node, parent: Node): boolean;
export declare function pointIn(x: number, y: number, element: Element | Node): boolean;
export declare function removeEl(el: Node | Node): Node;
/**
 * get page root scroll(body or documentElement). refer: https://stackoverflow.com/questions/871399/cross-browser-method-for-detecting-the-scrolltop-of-the-browser-window
 * @returns
 */
export declare function getScroll(): {
    top: number;
    left: number;
};
/**
 * relative to page root element(document.documentElement). refer: https://gist.github.com/aderaaij/89547e34617b95ac29d1
 * 相对于页面根元素.(document.documentElement)
 * @param el
 * @returns
 */
export declare function getOffset(el: Element): {
    x: number;
    y: number;
};
/**
 * there is some trap in el.offsetParent, so use this func to fix
 * @param el
 * @returns
 */
export declare function getOffsetParent(el: HTMLElement): HTMLElement;
/**
 * get el current position. like jQuery.position. The position is relative to offsetParent viewport left top. it is for set absolute position, absolute position is relative to offsetParent viewport left top.
 * 相对于offsetParent可视区域左上角(el.offsetLeft或top包含父元素的滚动距离, 所以要减去). position一般用于设置绝对定位的情况, 而绝对定位就是以可视区域左上角为原点.
 * @param el
 * @returns
 */
export declare function getPosition(el: HTMLElement): {
    x: number;
    y: number;
};
/**
 * like jQuery.offset(x, y), but it just return cmputed position, don't update style
 * 类似 jQuery.offset的设置功能, 但是它只返回计算的position, 不改变元素样式.
 * @param el
 * @param of
 * @returns
 */
export declare function getPositionFromOffset(el: HTMLElement, of: {
    x: number;
    y: number;
}): {
    x: number;
    y: number;
};
/**
 * relative to viewport. like position fixed. alias getViewportPosition
 * 相对于视口. 类似 position fixed. 别名 getViewportPosition
 * @param el
 * @returns
 */
export declare function getBoundingClientRect(el: Element): DOMRect;
export declare const getViewportPosition: typeof getBoundingClientRect;
export declare type ViewportPosition = ReturnType<typeof getViewportPosition>;
/**
 * position fixed is not always related to viewport.
 * position fixed不总是相对于视口.
 * 参考/Check: https://developer.mozilla.org/en-US/docs/Web/CSS/position
 * @param el
 * @param viewportPosition
 */
export declare function viewportPositionToFixed(el: Node, viewportPosition: {
    x: number;
    y: number;
}): {
    x: number;
    y: number;
};
export declare function findParent<T extends Element>(el: T, callback: (parentEl: Element) => boolean | "break" | undefined | void, opt?: {
    withSelf?: boolean;
    until?: Element;
    withUntil?: boolean;
}): HTMLElement | T;
export declare function backupAttr(el: Element, name: string): void;
export declare function restoreAttr(el: Element, name: string): void;
export declare function hasClass(el: Element, className: string): boolean;
/**
 * has all classNames
 * @param el
 * @param classNames
 */
export declare function hasClasses(el: Element, classNames: string[]): boolean;
/**
 * has any class in classNames
 * @param el
 * @param classNames
 * @returns
 */
export declare function hasClassIn(el: Element, classNames: string[]): boolean;
export declare function addClass(el: Element, className: string | string[]): void;
export declare function removeClass(el: Element, className: string | string[]): void;
export declare function getElSizeEvenInvisible(el: HTMLElement): {
    width: number;
    height: number;
};
/**
 * [isOffsetInEl]
 * @param {Number} x
 * @param {Number} y
 * @param {Object} el HTML Element
 */
export declare function isOffsetInEl(x: number, y: number, el: HTMLElement): boolean;
export declare function setElChildByIndex(el: Node, child: Node, index: number): void;
/**
 * listen event on element
 * @param el
 * @param name
 * @param handler
 * @param options
 */
export declare function on<T extends Event>(el: Node | Window | Document, name: string, handler: (event: T) => void, options?: boolean | AddEventListenerOptions): void;
/**
 * cancel event lisitener on element
 * @param el
 * @param name
 * @param handler
 * @param options
 */
export declare function off<T extends Event>(el: Node | Window | Document, name: string, handler: (event: T) => void, options?: boolean | AddEventListenerOptions): void;
/**
 * listen event on element once. return destroy function
 * @param el
 * @param name
 * @param handler
 * @param options
 * @returns destroy
 */
export declare function once<T extends Event>(el: Node | Window | Document, name: string, handler: (event: T) => void, options?: boolean | AddEventListenerOptions): () => void;
/**
 * lisiten multi events, and can stop and resume them. start listening by default. start is alias for resume
 * @param info
 * @returns
 */
export declare function extendedListen(info: [
    element: Element | Window | Document,
    name: string,
    handler: (event: any) => void,
    options?: boolean | AddEventListenerOptions
][]): {
    listening: boolean;
    stop: () => void;
    resume: () => void;
    start: () => void;
};
export declare function getImageSizeByUrl(url: string): Promise<{
    width: number;
    height: number;
}>;
export declare function elementsFromPoint(x: number, y: number): Element[];
export declare function getOuterAttachedHeight(el: Element, opt?: {
    margin?: boolean;
    border?: boolean;
}): number;
export declare function getOuterAttachedWidth(el: Element, opt?: {
    margin?: boolean;
    border?: boolean;
}): number;
/**
 * like jquery $(el).css(), but only can read
 * @param el
 * @param name
 * @returns
 */
export declare function css(el: Element, name: string): string | undefined;
export declare function cssNumber(el: Element, name: string): number;
export declare function isScrollable(el: Element, direction: "x" | "y"): boolean;
/**
 * scrollLeft, scrollRight, scrollTop, scrollBottom.
 * IMPORTANT! The min value of  scrollRight and scrollBottom may be a float less than 1, not zero.
 * 重要! scrollRight和scrollBottom的最小值可能是小于1的小数, 而不是0.
 * @param el
 * @param direction
 * @returns
 */
export declare function getScrollSpace(el: Element, direction: "left" | "right" | "top" | "bottom"): number;
export declare function scrollTo(options: {
    x?: number;
    y?: number;
    duration?: number;
    element?: Element;
    beforeEveryFrame?: (count: number) => boolean | void;
}): () => void;
export declare function insertBefore(el: Node, target: Node): void;
export declare function insertAfter(el: Node, target: Node): void;
export declare function prependTo(el: Node, target: Node): void;
export declare function appendTo(el: Node, target: Node): void;
export declare function cloneDate(dateObj: Date): Date;
export declare function addDate(dateObj: Date, n: number, type: "year" | "month" | "day" | "date" | "hour" | "minute" | "second" | "millisecond"): Date;
export declare function getMonthStart(dateObj: Date): Date;
export declare function getMonthEnd(dateObj: Date): Date;
export declare type GetCalendarDay = {
    year: number;
    month: number;
    date: number;
    text: number;
    prevMonth?: boolean;
    currentMonth?: boolean;
    nextMonth?: boolean;
};
/**
 * startWeekDay: 0 is Sunday
 * @param year
 * @param month
 * @param startWeekDay
 * @returns [GetCalendarDay x 7][]
 */
export declare function getCalendar(year: number, month: number, startWeekDay?: number): GetCalendarDay[][];
/**
 * timezone must be UTC. eg: 2018-09-07T03:38:37.888Z
 * @param str
 * @returns
 */
export declare function isIsoFormat(str: string): boolean;
/**
 *
 * @param timestamp eg: 2018-09-07T03:38:37.888Z
 * @returns
 */
export declare function parseISO(timestamp: string): Date;
export declare type BinarySearchReturn<T> = {
    index: number;
    value: T;
    count: number;
    hit: boolean;
    greater?: boolean;
} | null;
export interface BinarySearchOptions {
    start?: number;
    end?: number;
    returnNearestIfNoHit?: boolean;
    maxTimes?: number;
}
/**
 * binarySearch, 二分查找
 * @param arr
 * @param callback return `mid - your_value` for ascending array
 * @param opt
 * @returns
 */
export declare function binarySearch<T>(arr: T[], callback: (mid: T, index: number, count: number) => number, opt?: BinarySearchOptions): BinarySearchReturn<T>;
export declare function windowLoaded(): Promise<void>;
export declare function waitTime(milliseconds: number, callback?: () => void): Promise<void>;
export declare function waitFor(condition: () => boolean, time?: number, maxTimes?: number): {
    promise: Promise<void>;
    stop: () => void;
};
export declare function retry(action: any, limitTimes?: number): Promise<any>;
/**
 * Copy to text to clipboard. Async not supported. Recommend clipboard-polyfill.
 * 复制文字到剪贴板. 仅限于简单使用, 不支持异步. 复杂环境推荐clipboard-polyfill
 * @param text
 * @returns
 */
export declare function copyTextToClipboard(text: string): void;
export declare function isWindowDefined(): boolean;
export declare function isNode(): boolean;
export declare function isIE(): boolean;
export declare function openWindow(url: string, name: string, opt?: any): void;
export declare function openCenterWindow(url: string, name: string, width: number, height: number, opt?: any): void;
export declare function openPreviewWindow(previewUrl: string, name?: string, width?: number, height?: number): void;
export declare class URLHelper {
    baseUrl: string;
    search: {
        [key: string]: string;
    };
    constructor(baseUrl: string);
    getHref(): string;
}
export declare function resolveArgsByType(args: any[], types: any[]): any[];
export declare function makeStorageHelper<T extends Storage>(storage: T): {
    storage: T;
    set(name: string, value: any, minutes: number): void;
    get(name: string): any;
    clear(): void;
};
export declare const extendedLocalStorage: {
    action: () => {
        storage: Storage;
        set(name: string, value: any, minutes: number): void;
        get(name: string): any;
        clear(): void;
    };
    clearCache: () => void;
};
export declare const extendedSessionStorage: {
    action: () => {
        storage: Storage;
        set(name: string, value: any, minutes: number): void;
        get(name: string): any;
        clear(): void;
    };
    clearCache: () => void;
};
/**
 * Base event process. like event bus
 * 事件处理. 类似event bus
 */
export declare class EventProcessor {
    eventStore: any[];
    on(name: string, handler: any): void;
    once(name: string, handler: any): () => void;
    onceTimeout(name: string, handler: any, timeout: number): {
        off: () => void;
        promise: Promise<void>;
    };
    off(name: string, handler: any): void;
    emit(name: string, ...args: any[]): void;
}
/**
 * Pass event cross window
 */
export declare class CrossWindowEventProcessor extends EventProcessor {
    storageName: string;
    windows: any[];
    timeout: number;
    id: string;
    ready: Promise<void>;
    constructor(opt: {
        timeout?: number;
    });
    isMain(): boolean;
    BROADCAST: string;
    emitTo(name: string, targets: any, ...args: any[]): void;
    emitLocal(name: string, ...args: any[]): void;
    broadcast(name: string, ...args: any[]): void;
    emit(name: string, ...args: any[]): void;
    exitGroup(): void;
}
/**
 * on continuous input. return destroy
 * 监听连续输入事件. 返回取消监听函数. 例如监听用户输入aa
 * @param handler
 * @param opt
 * @returns
 */
export declare function onContinuousInput(handler: (input: string) => void, opt?: {
    timeout?: number;
}): () => void;
export declare const onQuickKeydown: typeof onContinuousInput;
export declare function getUserLanguage(): string;
export declare class Cache {
    store: {};
    has(name: string): boolean;
    remember(name: string, getter: () => any): any;
    forget(name: string): void;
}
export declare function attachCache(obj: any, toCache: object, cache?: Cache): void;
export declare function easeInOutQuad(startValue: number, changeInValue: number, changedTime: number, duration: number): number;
export declare function isMobile(): boolean;
export declare class Accumulate<T> {
    arr: T[];
    cache: number[];
    constructor(arr: T[]);
    getValue(item: T): number;
    sum(index: number): number;
}
/**
 * from https://www.zhangxinxu.com/wordpress/2018/08/css-svg-background-image-base64-encode/
 * @param svgCode
 * @returns
 */
export declare function svgToDataURL(svgCode: string): string;
export declare function genRandomLightColor(): string;
/**
 * Like Map, support array as key. array order is used.
 */
export declare class ArrayKeyMap<T> {
    _map: Map<any, [string, number]>;
    _values: Record<string, [any[], T]>;
    _objCount: number;
    _keysToString(keys: any[]): string | null;
    has(keys: any[]): boolean;
    /**
     * throw error if not found
     * @param keys
     * @returns
     */
    get(keys: any[]): T;
    set(keys: any[], value: T): void;
    delete(keys: any[]): void;
    clear(): void;
    entries(): Generator<(any[] | T)[], void, unknown>;
    count(): number;
}
export declare type ParametersWithoutFirst<T extends (...args: any) => any> = T extends (first: any, ...args: infer P) => any ? P : never;
/**
 * Remove function's first parameter
 */
export declare type OmitFirstParameter<F> = F extends (x: any, ...args: infer P) => infer R ? (...args: P) => R : never;
export declare type ReplaceReturnType<T extends (...a: any) => any, TNewReturn> = (...a: Parameters<T>) => TNewReturn;
export declare type Nullable<T> = T | null;
